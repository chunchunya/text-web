# 1.数据类型判断（typeof）

```js
function typeOf(obj) {
    return Object.prototype.toString.call(obj).slice(8,-1).toLowerCase();
}
//或
function typeOf(obj){
  return Object.prototype.toString.call(obj).split(' ')[1].slice(0,-1).toLowerCase();
}
```

# 2.数组去重

```js
let num = [1,2,1,2,3,4,7,6,5,4,3,2];

//方法一，使用filter
function unique(num){
   return num.filter((item,index)=>{
        return num.indexOf(item) === index;
    })
}
console.log(unique(num));

//方法二，使用reduce
function unique1(num){
    return num.reduce((prev,cur)=>{
        if(!prev.includes(cur)){
            prev.push(cur);
        }
        return prev;
    },[]);
}
console.log(unique1(num));

//方法三：ES6方法
console.log([...(new Set(num))]);
```

# 3.数组扁平化

```js
//方法一： 使用flat()方法
注：我运行的时候会报错，提示arr的属性没有这个方法（不推荐）
let arr = [1,[2,3,4,5,[6,7,[8]]],9];
let res = arr.flat(Infinity);
console.log(arr);

//方法二：递归方法
let newArr = [];
function squeeze(arr){
    for(let i=0;i<arr.length;i++){
        if(Array.isArray(arr[i])){  //if(arr[i] instanceof Array)
            squeeze(arr[i]);
        }else{
            newArr.push(arr[i]);   //这里必须写成else形式
        }
    }
    return newArr
}
let arr3 = squeeze(arr);
console.log(arr3);

//方法三：reduce+递归方法
//reduce实现数组的扁平化
let arr1 = [1,2,[3,4,5,[6,7,[8]]],9];
let newArr = (arr)=>{
    return arr.reduce(function(prev,cur){
        return prev.concat((Array.isArray(cur))?newArr(cur):cur)
    },[])
}
console.log(newArr(arr1));

//ES6实现
function flatten(arr) {
    while (arr.some(item => Array.isArray(item))) {
        arr = [].concat(...arr);
    }
    return arr;
}
```

# 4.深浅拷贝

```js
//深拷贝1
let deepCopy = (newObj,oldObj)=>{
    for(let key in oldObj){
        let item= oldObj[key];
        if(item instanceof Array){
            newObj[key] = [];
            deepCopy(newObj[key],item);

        }else if(item instanceof Object){
            newObj[key] = {};
            deepCopy(newObj[key],item);
        }else{
            newObj[key] = item;
        }
    }
    return newObj;
}

//深拷贝2的写法
let deepCopy2 = (obj)=>{
    let copyObj = {};
    if(obj === null) return obj;    //null也是一个空对象
    if(obj instanceof Date) return new Date(obj);   //判断日期和正则
    if(obj instanceof RegExp) return RegExp(obj);
    if(typeof obj !== 'object') return obj;
    for(let key in obj){
        if(obj.hasOwnProperty(key)){
            copyObj[key] = deepCopy2(obj[key]);
        }

    }
    return copyObj;
}

//深拷贝还可以用JSON.parse(JSON.stringify(obj))  但是缺点是函数不拷贝，正则也不拷贝

//浅拷贝
let shallowCopy = (oldObj)=>{
    let newObj = {};
    for(let i in oldObj){
        if(oldObj.hasOwnProperty(i)){
            newObj[i] = oldObj[i];
        }

    }
    return newObj;
}

var obj1 = {
    name: '你的名字',
    age: 30,
    hobby:{
        '体育':'打篮球',
        '学习':'看书',
        '生活':'逛街'
    }
}

var obj2 = shallowCopy(obj1);

var obj3 = deepCopy({},obj1);
var obj4 = deepCopy2(obj1)

obj2.name = "变成obj2的名字";
obj2.hobby['体育']= 'obj2打羽毛球';


obj3.name = "变成obj3的名字";
obj3.hobby['体育'] = 'obj3打羽毛球';

obj4.name = "变成obj4的名字";
obj4.hobby['体育'] = 'obj4打羽毛球';

console.log(obj1);       //对于obj2的浅拷贝，name没有变，还是原来的"你的名字"  对象中的"体育"属性变了，变成了和obj2改的一样的   对于obj3的深拷贝，都没有变，两者互不影响
console.log(obj2);
console.log(obj3);
console.log(obj4);
```

# 5.事件总线（发布订阅模式）