---
title: 从0到1的Vue-demo搭建
date: 2022/09/15
author:张玉春
---

# 1.脚手架搭建Vue前端框架

1.首先先全局安装**vue-cli**(本设备已进行过全局安装，无需再次安装)，安装完成输入**vue -V**可以其安装的版本号，如出现则说明安装成功~

2.搭建项目（公司使用基本都是vue2版本，所以默认搭建vue2版本的项目）

```javascript
//进入到要创建项目的文件夹
vue create demo   //此处demo为项目名称
```

​         如果没有要求可以直接回车选择默认生成一个项目。选择自定义创建项目的话根据弹出的各种项目生成选择，选择适合你的开发模式（此处要选择vue2项目，同时将）当时设置如下：

![image-20220915104432563](从0到1demo搭建过程.assets/image-20220915104432563.png)

3.生成项目成功后便可输入如下指令打开项目且可以在此项目中进行创作了！

```javascript
npm run serve   //vue-cli3版本以上都是serve  以下版本为npm run dev
```

4.根据项目需求进行各个组件的安装

```javascript
npm install //全部组件安装
npm install XXX@XXX //安装指定版本的组件库
```

# 2.更改入口文件main.js

运行项目后首先就是查看app.vue文件和main.js文件，删除并更改一些东西。main.js是项目的入口文件，可以在此文件进行各种组件的引用加载（前提是已经安装）和使用，并且该文件已自动挂在主页面文件app（默认）

main.js文件配置

![image-20220915105856613](从0到1demo搭建过程.assets/image-20220915105856613.png)

app.vue文件配置

![image-20220915110112775](从0到1demo搭建过程.assets/image-20220915110112775.png)

# 3. 设计路由

1.找到路由文件（创建项目时已自动给创建了路由文件）

整个项目路由设计如下：



路由文件代码配置格式如下：

![image-20220915111216350](从0到1demo搭建过程.assets/image-20220915111216350.png)

![image-20220915111639001](从0到1demo搭建过程.assets/image-20220915111639001.png)

![image-20220915111825576](从0到1demo搭建过程.assets/image-20220915111825576.png)

![image-20220915111920244](从0到1demo搭建过程.assets/image-20220915111920244.png)

整体路由设计.xmind图如下：

![路由设计](从0到1demo搭建过程.assets/路由设计.png)

整个页面布局代码布局：

![image-20220915135146548](从0到1demo搭建过程.assets/image-20220915135146548.png)

# 4.页面布局

采用魔方组件（类似element组件）中的container布局组件，将BasicLayout.vue（主页）文件里拆分成四块，即Header、Side、Foot以及main内容区。也就是该页面存在四个子组件（Header.vue、Footer.vue、SiderMenu.vue和子路由组件（Analysis.vue））

![image-20220915142002107](从0到1demo搭建过程.assets/image-20220915142002107.png)

# 5.如何将菜单栏与路由动态结合（递归方式）

js部分，利用递归方法将我们想要的（过滤）路由实例存放到另一个数组中，然后页面循环渲染。js逻辑如下：（注意：**利用this.$router.options.routes可直接获取到我们设置好的路由实例对象**）

![image-20220915144749744](从0到1demo搭建过程.assets/image-20220915144749744.png)

页面渲染采用魔方组件中导航栏NavMenu导航菜单栏组件，循环渲染路由对象（注意这个组件有个非常方便的可以直接将对应导航栏对应各自的路由路径设置，如图所示）

![image-20220915142729359](从0到1demo搭建过程.assets/image-20220915142729359.png)

# 6.使用nprogress插件（通过npm下载）

为了提升用户体验，想设置一个在路由跳转的过程中显示一个进度条的功能，下载插件，使用路由导航守卫实现进度条显示功能，如下所示。因为是全局使用，所以在路由文件中进行配置。

首先，下载安装后引入

![image-20220915143404254](从0到1demo搭建过程.assets/image-20220915143404254.png)

之后，

![image-20220915143603942](从0到1demo搭建过程.assets/image-20220915143603942.png)

# 7.使用路由管理用户权限

1.首先在路由配置文件中，为每一个路由加上用户的权限信息，例如下所示：

![image-20220915144001959](从0到1demo搭建过程.assets/image-20220915144001959.png)

2.创建一个utils/auth.js文件用于将一些校验函数全部汇总集结于此文件

![image-20220915145905998](从0到1demo搭建过程.assets/image-20220915145905998.png)

3.在router.js(路由配置文件)中的路由守卫中需要做一些判断

![image-20220915150244637](从0到1demo搭建过程.assets/image-20220915150244637.png)

使用lodash插件中提供给我们的一些方法

![image-20220915155159774](从0到1demo搭建过程.assets/image-20220915155159774.png)

​		**注意：to.matched（即将去到的路由  .matched是路由提供给我们的一个接口，可以从该字段中取到我们当前访问的路由所匹配到的所有路由信息）**

![image-20220915150928340](从0到1demo搭建过程.assets/image-20220915150928340.png)

使用lodash插件中的findLast()方法，目的是找到距离该路由最近的父路由的用户权限信息

**插曲：**  lodash中findLsat()用法：**从右到左遍历返回第一个满足函数条件的实例或值**

```javascript
.findLast() 方法从右到左迭代集合中的元素。和.find()方法差不多。
语法：
.findLast( collection, predicate, fromIndex )
参数：该方法接受三个参数：
collection：方法迭代的集合。
predicate：它是每次迭代调用的函数。
fromIndex：数组的索引，从哪里开始搜索。
返回值：此方法返回匹配的元素，否则未定义。
```

# 8.更加精细化的权限设计（权限组件、权限指令）

方法一：创建权限组件（然后在需要权限来限制某个功能的template里引入）

1.创建一个函数式组件Authorized.vue（权限校验组件）,并设置如下（并不是很懂）

![image-20220915173144175](从0到1demo搭建过程.assets/image-20220915173144175.png)

2.因为会经常用到该组件，所以在main.js文件中注册成全局组件，这里注册全局组件有一丢丢不太一样，需要注意：

![image-20220915173643939](从0到1demo搭建过程.assets/image-20220915173643939.png)

此时，我们可以使用该权限校验组件了，举例如下：（比如这个基础表单里的这个整个from表单只有管理员才能看到，那我们可以这么设置）

![image-20220915174015559](从0到1demo搭建过程.assets/image-20220915174015559.png)

![image-20220915174328943](从0到1demo搭建过程.assets/image-20220915174328943.png)

看不到了~（说明设置成功！！）

![image-20220915174917866](从0到1demo搭建过程.assets/image-20220915174917866.png)

方法二：设置权限指令

1.创建一个指令文件，并编写代码如下（也没太搞懂是为什么）

![image-20220915180335612](从0到1demo搭建过程.assets/image-20220915180335612.png)

2.在main.js中全局进入该文件并使用

![image-20220915180453535](从0到1demo搭建过程.assets/image-20220915180453535.png)

3.还是上面那个例子（比如这个基础表单里的这个整个from表单只有管理员才能看到，那我们可以这么设置）

![image-20220915180609988](从0到1demo搭建过程.assets/image-20220915180609988.png)

直接在标签中添加指令即可，想让谁看就让谁看，方便简单！！！

总结：指令式组件有一定的弊端（只有第一次才有权限控制，如果权限动态更改了，那么就不好使了，一般情况下也不怎么权限配置变动）

组件式权限控制比较灵活一些，唯一的弊端就是写法不太方便

# 9.对axios进行二次封装

在代码设置文件中新建一个request.js文件，用于对axios请求进行二次封装，如下是对axios的一个简单封装，之后应该更饱满些，在下面mock数据章节中使用到了此次封装好的request方法进行get请求。

![image-20220924193016161](从0到1demo搭建过程.assets/image-20220924193016161.png)

# 10.如何高效地使用Mock数据进行开发

1.开发成本比较小且比较灵活的mock开发方案

2.好用的工具：apifox、yapi、mock.js

本次项目使用mock.js来mock数据

**mock.js定义请求**

语法：

```javascript
Mock.mock( rurl?, rtype?, template|function(options) )
```

参数：

​	 rurl：可选。表示需要拦截的 URL，可以是 URL 字符串或 URL 正则。例如//domain/list.json/、‘/domian/list.json’。
​	 rtype：可选。表示需要拦截的 Ajax.请求类型。例如 GET、POST、PUT、DELETE 等。
​	 template：可选。表示数据模板，可以是对象或字符串。
​	 function(options)：可选。表示用于生成响应数据的函数。
​	 options：指向本次请求的 Ajax 选项集。

原文链接：https://blog.csdn.net/m0_59232123/article/details/123760879

1.创建mock.js文件，配置如下：生成一些数据：

![image-20220924181455967](从0到1demo搭建过程.assets/image-20220924181455967.png)

在对应的文件中调用mock接口，在控制台可成功返回数据。

![image-20220924190104225](从0到1demo搭建过程.assets/image-20220924190104225.png)

![image-20220924190529321](C:\Users\zhangyc-n\AppData\Roaming\Typora\typora-user-images\image-20220924190529321.png)

# 11.todolist案例

![image-20220924191127919](从0到1demo搭建过程.assets/image-20220924191127919.png)

新增编辑功能：

![image-20220926163523305](从0到1demo搭建过程.assets/image-20220926163523305.png)

功能点：（数据在父组件todoList中）

1.List组件为Item组件传值（涉及**父传子Props的使用**）

2.在头部组件输入文字按回车可以添加todo事项（涉及知识点：**子给父传值（自定义事件）**）

3.每一个Item事项可以进行勾选已完成和删除（这里用到**事件总线**进行传值（也尝试过**发布订阅方式**））

4.每一个Item事项可以进行编辑（编辑过程中涉及到**nextTick**的使用）

5.在底部组件中可以记录已完成事项和全部事项（涉及**computed计算属性**使用）

   清除已完成任务（涉及**子向父传递数据**知识）

6.对数据在浏览器进行存储（**使用localStorage存储**，每次更改数据后保留更新状态，刷新浏览器数据不改变），同时利用**watch监视属性**对数据进行监视

组件结构设计如下：

![image-20220924192100026](从0到1demo搭建过程.assets/image-20220924192100026.png)

# 12.引用vue-echarts

1.首先安装并在main.js中进行引用

```javascript
npm install vue-echarts
```

![image-20220924192328433](从0到1demo搭建过程.assets/image-20220924192328433.png)

2.在对应页面使用vue-echarts各个图表

![image-20220924192653368](从0到1demo搭建过程.assets/image-20220924192653368.png)

![image-20220924192537023](从0到1demo搭建过程.assets/image-20220924192537023.png)

# 13.将二级导航菜单改为三级导航菜单

主要改动文件在SiderMenu组件中，（将路由中第三级的菜单改为不隐藏，使得获取到三级路由后再进行三级导航渲染），渲染主要逻辑如下：

![image-20220924193618271](从0到1demo搭建过程.assets/image-20220924193618271.png)