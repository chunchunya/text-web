# 树的建立以及前序中序后序遍历

```javascript
var TreeNode = (val)=>{
    this.val = val;
    this.left = null;
    this.right = null;
}

//递归方法
// var traversal = (root)var TreeNode = (val)=>{
    this.val = val;
    this.left = null;
    this.right = null;
}

//递归方法
var traversal = (root)=>{
    if(root){
        // //先序
        // console.log(root);
        // traversal(root.left);
        // traversal(root.right);

        // //中序
        // traversal(root.left);
        // console.log(root);
        // traversal(root.right);

        //后序
        traversal(root.left);
        traversal(root.right);
        console.log(root);
    }
}

//非递归方法
//前序
var pre = (root)=>{
    if(root) {
        let stack = [];
        //先将根节点push
        stack.push(root);
        //判断栈中是否为空
        while (stack.length > 0) {
            //弹出栈顶元素
            root = stack.pop();
            console.log(root);
            //因为先序遍历是先左后右，栈是先进后出结构
            //所以先push右边再push左边
            if (root.right) {
                stack.push(root.right);
            }
            if (root.left) {
                stack.push(root.left);
            }
        }
    }
}

//中序
//中序遍历是先左再根最后右
//所以首先应该先把最左边的节点遍历到底依次push进栈
//当左边没有节点时，就打印栈顶元素，然后寻找右节点
//对于最左边的叶节点来说，可以把它看作两个null节点的父节点
//左边打印不出东西就把父节点拿出来打印然后再看右节点
var middle = (root)=> {
    if (root) {
        let stack = [];
        while(stack.length>0||root){
            if(root){
                stack.push(root);
                root = root.left;   //一直往左走走到最左边的叶节点，相当于把最左边的叶节点当作父节点
            }else{
                root = stack.pop();
                console.log(root);
                root = root.right;
            }
        }
    }
}

//后序遍历
//使用两个栈来实现遍历
var post = (root)=>{
    if(root){
        let stack1 = [];
        let stack2 = [];
        //后序遍历是先左再右最后根
        //所以对于一个栈来说，应该先push根节点
        //然后push右节点，最后push左节点
        stack1.push(root);
        while(stack1.length>0){
            root = stack1.pop();
            stack2.push(root);
            if(root.left){
                stack1.push(root.left);
            }
            if(root.right){
                stack1.push(root.right);
            }

        }
        while(stack2.length>0){
            console.log(stack2.pop());
        }
    }
}=>{
//     if(root){
//         // //先序
//         // console.log(root);
//         // traversal(root.left);
//         // traversal(root.right);
//
//         // //中序
//         // traversal(root.left);
//         // console.log(root);
//         // traversal(root.right);
//
//         //后序
//         traversal(root.left);
//         traversal(root.right);
//         console.log(root);
//     }
// }

//非递归方法
//前序
var pre = (root)=>{
    if(root) {
        let stack = [];
        //先将根节点push
        stack.push(root);
        //判断栈中是否为空
        while (stack.length > 0) {
            //弹出栈顶元素
            root = stack.pop();
            console.log(root);
            //因为先序遍历是先左后右，栈是先进后出结构
            //所以先push右边再push左边
            if (root.right) {
                stack.push(root.right);
            }
            if (root.left) {
                stack.push(root.left);
            }
        }
    }
}

//中序
//中序遍历是先左再根最后右
//所以首先应该先把最左边的节点遍历到底依次push进栈
//当左边没有节点时，就打印栈顶元素，然后寻找右节点
//对于最左边的叶节点来说，可以把它看作两个null节点的父节点
//左边打印不出东西就把父节点拿出来打印然后再看右节点
var middle = (root)=> {
    if (root) {
        let stack = [];
        while(stack.length>0||root){
            if(root){
                stack.push(root);
                root = root.left;   //一直往左走走到最左边的叶节点，相当于把最左边的叶节点当作父节点
            }else{
                root = stack.pop();
                console.log(root);
                root = root.right;
            }
        }
    }
}

//后序遍历
//使用两个栈来实现遍历
var post = (root)=>{
    if(root){
        let stack1 = [];
        let stack2 = [];
        //后序遍历是先左再右最后根
        //所以对于一个栈来说，应该先push根节点
        //然后push右节点，最后push左节点
        stack1.push(root);
        while(stack1.length>0){
            root = stack1.pop();
            stack2.push(root);
            if(root.left){
                stack1.push(root.left);
            }
            if(root.right){
                stack1.push(root.right);
            }

        }
        while(stack2.length>0){
            console.log(stack2.pop());
        }
    }
}
```

# DFS和BFS

```javascript
//DFS 深度优先遍历   递归版本
var deepFirstSearch = (node,nodeList)=>{
    nodeList = [];
    if(node){
        nodeList.push(node);
        let children = node.children;
        for(let i=0;i<children.length;i++){
            //每次递归的时候将需要遍历的节点和节点所存储的数组传下去
            deepFirstSearch(children[i],nodeList);
        }

    }
    return nodeList;
}

//DFS 非递归版本
var deepFirstSearch = (node)=>{
    let nodeList = [];
    if(node){
        let stack = [];
        stack.push(node);
        while(stack.length!==0){
            let item = stack.pop();
            nodeList.push(item);
            let children = item.children;
            for(let i=0;i<children.length;i++){
                stack.push(children[i]);
            }

        }


    }
    return nodeList;
}

//deepFirstSearch接受两个参数，第一个参数是需要遍历的节点，第二个是节点所存储的数组，并且返回遍历完之后的数组，该数组的元素顺序就是遍历顺序，调用方法：
        //let root = document.getElementById('root')
        // deepTraversal(root,nodeList=[])



//BFS 递归版本的BFS由于层级太深，会导致堆栈溢出。Maximum call stack size exceeded，但遍历的顺序依旧没有问题，可以在遍历过程中进行操作，不返回遍历数组即可。
//BFS 一般写非递归
var breadthFirstSearch = (node)=>{
    let nodes = [];
    if (node != null) {
        var queue = [];
        queue.unshift(node);
        while (queue.length != 0) {
            var item = queue.shift();
            nodes.push(item);
            var children = item.children;
            for (var i = 0; i < children.length; i++)
                queue.push(children[i]);
        }
    }
    return nodes;
}

//BFS 非递归版本  用到队列
var breadthFirstSearch = (node)=>{
    let nodes = [];
    if(node){
        let queue = [];
        queue.unshift(node);
        while(queue.length!==0){
            let item = queue.shift();
            nodes.push(item);
            let children = item.children;
            for(let i=0;i<children,length;i++){
                queue.push(children[i]);
            }
        }

    }
    return nodes;
}
```

# 排序类

## 冒泡

## 选择

## 插入

## 快排

## 希尔

## 归并

## 堆排序

