# 同源和跨域

**同源策略**是浏览器的一种安全策略，所谓同源是指，域名，协议，端口（http协议的默认端口是80）完全相同。

同源策略主要**限制**了三个方面：

1. **DOM层面**：不同源站点之间不能相互访问和操作DOM
2. **数据层面**：不能获取不同源站点的Cookie、LocalStorage、indexDB等数据
3. **网络层面**：不能通过XMLHttpRequest向不同源站点发送请求（不能发送Ajax请求）

当然**同源策略限制也不是绝对隔离不同源的站点**，比如link、img、script标签都没有跨域限制，这让我们开发更灵活了，但是也同样带来了一些安全问题，也就是**浏览器网络安全**问题，最典型的就是XSS攻击和CSRF攻击。

## XSS攻击（Cross Site Scripting—跨域脚本攻击）

XSS攻击是一种`代码注入攻击`，通过恶意注入脚本在浏览器运行，然后盗取用户信息

**造成XSS攻击其实本质上还是因为网站没有过滤恶意代码，与正常代码混在一起之后，浏览器没有办法分辨哪些是可信的，然后导致恶意代码也被执行**。然后可能导致以下情况：

- 页面数据或用户信息被窃取，如DOM、Cookie、LocalStorage

- 修改DOM，比如伪造登录窗口或在页面生成浮窗广告

- 监听用户行为，比如在登录或银行等站点用 addEventListener 监听键盘事件，窃取账号密码等信息

- 流量被劫持向其他网站

  XSS攻击有三种类型：**存储型**、**反射型**、**DOM型**

  #### 存储型 XSS

  存储型 XSS 的攻击步骤：

  攻击者将恶意代码提交到目标网站的数据库中。 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。

  #### 反射型 XSS

  反射型 XSS 的攻击步骤：

  - 攻击者构造出特殊的 URL，其中包含恶意代码。
  - 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。
  - 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
  - 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

  反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。

  反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。

  由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。

  POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。

  #### DOM 型 XSS

  DOM 型 XSS 的攻击步骤：

  - 攻击者构造出特殊的 URL，其中包含恶意代码。
  - 用户打开带有恶意代码的 URL。
  - 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。
  - 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

  DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。

  **防护策略：**

  - 就是对输入框的内容进行`过滤`或使用转义符进行`转码`
  - 使用CSP，就是`白名单`，告诉浏览器哪些外部资源可以加载执行，让即使插入进来恶意代码的也不会执行，或者可以向哪些第三方站点提交数据。开启白名单的方式有两种：
    - 使用 meta 标签 `<meta http-equiv="Content-Security-Policy">`
    - 设置http头部的 `Content-Security-Policy`
  - 对一些敏感信息进行保护，在`Cookie`信息中添加`httpOnly`，告诉浏览器在保存Cookie，且不要对客户端脚本开放访问权限，然后就不能通过document.cookie获取cookie了

  ```
  Set-Cookie: widget_session=123456; httpOnly
  ```

  - 使用`验证码`，避免脚本伪装成用户执行一些操作

  **前端如何防护XSS攻击：**

  1. 前端在显示服务端数据时候，不仅是标签内容需要过滤、转义，就连属性值也都可能需要。

  2. 使用HTTPS！就跟我前面《[HTTP与HTTPS握手的那些事](http://www.cnblogs.com/lovesong/p/5186200.html)》这篇文章说的，HTTPS会在请求数据之前进行一次握手，使得客户端与服务端都有一个私钥，服务端用这个私钥加密，客户端用这个私钥解密，这样即使数据被人截取了，也是加密后的数据。

## CSRF攻击（Cross Site Request Forgery—跨站请求伪造）

**主要就是利用用户的登录状态发起跨站请求**，比如邮箱里的乱七八糟的链接，打开链接的时候邮箱肯定是处于登录状态，然后黑客就可以用这个登录状态，伪造带有正确 Cookie 的 http 请求，直接绕过后台的登录验证，然后冒充用户执行一些操作。

发起CSRF攻击有**三个必要条件**：

1. 目标网站一定要有CSRF漏洞

2. 用户登录过目标网站，并且浏览器保存了登录状态

3. 需要用户主动打开第三方站点

   CSRF攻击也有三种类型：**GET类型**、**POST类型**、**链接型**

   - `自动发GET类型`：比如`img`或`iframe`标签等，当用户打开这个网站时会自动发起带Cookie的资源请求

   ```html
   <img src="http://恶意网址" >
   复制代码
   ```

   - `自动发POST类型`：比如整一个隐藏的`表单`，在用户进入页面的时候自动提交表单

   ```html
   <form id="hack" action="https://恶意网址" method="post">
       ...
   </form>
   <script>document.getElementById('hack').submit()</script>
   复制代码
   ```

   - `诱导链接型`：就是诱导用户主动点击链接，比如`a标签`

   ```html
   <a href="https://恶意网址">点击领取大礼包</a>
   <a href="https://恶意网址">点击下载美女视频</a>
   ```

**防护策略**:

在Cookie信息中添加`SameSite`属性，这个属性有三个值：

- **strict**：**严格模式**，完全禁止使用Cookie
- **lax**：**宽松模式**，允许部分情况使用Cookie，`跨域的都行`，a标签跳转，link标签，GET提交表单
- **none**：任何情况下都会发送Cookie，但必须同时设置Secure属性，意思是需要安全上下文，Cookie 只能通过https发送，否则无效

Chrome 80之前默认值是none，之后是lax

```javascript
Set-Cookie: widget_session=123456; SameSite=None; Secure
```

`验证请求来源`：服务器根据http请求头中的`Origin`或`Referer`属性判断是否为允许访问的站点，从而对请求进行过滤。优先判断Origin，如果两个都不存在的话就直接阻止。

- Referer：记录了请求是从哪个链接跳过来的并且包含了路径信息，也就是来源地址。不过这家伙不太可靠，所以后来又新增了Origin属性

  ```
  Referer: https://juejin.cn/editor/drafts/xxxx
  ```

- origin：记录了域名信息，没有具体的URL路径

  ```
  Origin: https://juejin.cn
  ```

`Token验证`：服务器向用户返回一个随机数Token，再次请求时在请求头中以参数的形式添加入这个Token，然后服务器验证这个Token，如果没有或者内容不正确，就拒绝请求。缺点是

- 每个请求都得添加比较繁琐
- 单方面验证Cookie可能会被冒用，
- 如果网站不止一台服务器，通过负载均衡转到了其他服务器的话，其他所有服务器中的Session中都得保留Token，不然就验证不了了

`双重验证Cookie`：利用攻击者只能利用Cookie，不能获取Cookie的特点，用户访问页面时，服务器向请求域名添加一个Cookie随机字符串，然后，用户再次请求时从Cookie中取出这个字符串，添加到URL参数中，然后服务器通过对Cookie中的数据和参数中的数据对比验证，不一样就拒绝请求。

**缺点**是如果网站存在XSS漏洞，这法子就会失效，而且不能做到子域名的隔离

# 跨域通信的几种方式

1. ## **JSONP**

   **JSONP的原理**：**通过`<script>`标签的异步加载来实现的**。比如说，实际开发中，我们发现，head标签里，可以通过`<script>`标签的src，里面放url，加载很多在线的插件。这就是用到了JSONP。

   **核心思想：**网页通过添加一个`<script>元素`，向服务器请求 JSON 数据，服务器收到请求后，将数据放在一个指定名字的回调函数的参数位置传回来。

   不过`只支持GET请求`且`不安全`，**可能遇到XSS攻击，不过它的好处是可以向老浏览器或不支持CORS的网站请求数据**

2. ## **WebSocket**

   [WebSocket](http://websocket.org/) 是一种网络通信协议，我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？因为 HTTP 协议有一个缺陷：通信只能由客户端发起。**HTTP 协议做不到服务器主动向客户端推送信息。**

   这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用["轮询"](https://www.pubnub.com/blog/2014-12-01-http-long-polling/)：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。

   WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。

   它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于[服务器推送技术](https://en.wikipedia.org/wiki/Push_technology)的一种。

   其他特点包括：

   （1）建立在 TCP 协议之上，服务器端的实现比较容易。

   （2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。

   （3）数据格式比较轻量，性能开销小，通信高效。

   （4）可以发送文本，也可以发送二进制数据。

   （5）**没有同源限制，客户端可以与任意服务器通信**。

   （6）协议标识符是`ws`（如果加密，则为`wss`），服务器网址就是 URL。

   WebSocket的用法如下：

   ```js
   var ws = new WebSocket('wss://echo.websocket.org'); //创建WebSocket的对象。参数可以是 ws 或 wss，后者表示加密。
   
   //把请求发出去
   ws.onopen = function (evt) {
   console.log('Connection open ...');
   ws.send('Hello WebSockets!');
   };
   
   
   //对方发消息过来时，我接收
   ws.onmessage = function (evt) {
   console.log('Received Message: ', evt.data);
   ws.close();
   };
   
   //关闭连接
   ws.onclose = function (evt) {
   console.log('Connection closed.');
   };
   ```

   ```js
   // socket.html
   <script>
       let socket = new WebSocket('ws://localhost:3000');//创建WebSocket的对象。参数可以是 ws 或 wss，后者表示加密。
       socket.onopen = function () {
         socket.send('我爱你');//向服务器发送数据
       }
       socket.onmessage = function (e) {
         console.log(e.data);//接收服务器返回的数据
       }
   </script>
   
   // server.js
   let express = require('express');
   let app = express();
   let WebSocket = require('ws');//记得安装ws
   let wss = new WebSocket.Server({port:3000});
   wss.on('connection',function(ws) {
     ws.on('message', function (data) {
       console.log(data);
       ws.send('我不爱你')
     });
   })
   ```

3. ## **代理Proxy**（只在生产环境中使用）

   ​		通过中间件来实现，浏览器有跨域限制，但是服务器没有跨域限制，所以中间件其实就是服务器（服务器对数据进行了转发），此方法在vue中经常用到（在vue的配置文件里设置代理）。

   ​		例如当baidu.com域下的页面需要请求google.com下的资源文件getUsers.php时，直接发送一个指向  google.com/getUsers.php的Ajax请求肯定是会被浏览器阻止。这时，我们在baidu.com下配一个代理，然后把Ajax请求绑定到这个代理路径下，例如baidu.com/proxy/,  然后这个代理发送HTTP请求访问google.com下的getUsers.php，跨域的HTTP请求是在服务器端进行的（服务器端没有同源策略限制），客户端并没有产生跨域的Ajax请求。这个跨域方式不需要和目标资源签订协议，带有侵略性。

   代理服务器需要做以下事情：

   - 接受客户端请求 。
   - 将请求转发给服务器。
   - 拿到服务器响应数据。
   - 将 响应转发给客户端。

   ![image-20210814133216235](../source/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3/image-20210814133216235.png)

   ![image-20210814134517030](../source/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3/image-20210814134517030.png)

4. ## **CORS**

   只需要在服务器端设置Access-Control-Allow-Origin即可（服务器允许跨域，若后面值为*号，则表示服务器允许所有的源都可以请求），前端无需配置，**若要带cookie请求**，则前端后端都需要配置。

   #### 简单请求

   需要同时满足两个条件，就属于简单请求：

   - 请求方法是：`HEAD`、`GET`、`POST`，三者之一
   - 请求头信息不超过以下几个字段：
     - Accept
     - Accept-Language
     - Content-Language
     - Last-Event-Id
     - Content-Type：值为三者之一application/x-www/form/urlencoded、multipart/form-data、text/plain

   需要这些条件是为了兼容表单，因为历史上表单一直可以跨域

   浏览器直接发出CORS请求，具体来说就是在头信息中增加Origin字段，表示请求来源来自哪个域(协议+域名+端口)，服务器根据这个值决定是否同意请求。如果同意，返回的响应会多出以下响应头信息

   ```js
   Access-Control-Allow-Origin: http://juejin.com // 和 Orign 一致  这个字段是必须的
   Access-Control-Allow-Credentials: true // 表示是否允许发送 Cookie  这个字段是可选的
   Access-Control-Expose-Headers: FooBar // 指定返回其他字段的值   这个字段是可选的
   Content-Type: text/html; charset=utf-8 // 表示文档类型
   复制代码
   ```

   在简单请求中服务器至少需要设置：`Access-Control-Allow-Origin` 字段

   #### 非简单请求

   比如 PUT 或 DELETE 请求，或 Content-Type 为 application/json ，就是非简单请求。

   非简单 CORS 请求，**正式请求前会发一次 OPTIONS 类型的查询请求**，称为`预检请求`，询问服务器是否支持网页所在域名的请求，以及可以使用哪些头信息字段。只有收到肯定的答复，才会发起正式XMLHttpRequest请求，否则报错

   预检请求的方法是OPTIONS，它的头信息中有几个字段

   - Origin: 表示请求来自哪个域，这个字段是必须的
   - Access-Control-Request-Method：列出CORS请求会用到哪些HTTP方法，这个字段是必须的
   - Access-Control-Request-Headers： 指定CORS请求会额外发送的头信息字段，用逗号隔开

   OPTIONS请求次数过多也会损耗性能，所以要尽量减少OPTIONS请求，可以让服务器在请求返回头部添加

   ```js
   Access-Control-Max-Age: Number // 数字 单位是秒
   复制代码
   ```

   表示预检请求的返回结果可以被缓存多久，在这个时间范围内再请求就不需要预检了。不过这个缓存只对完全一样的URL才会生效

5. ## **Hash**

   原理就是通过 url 带 hash ，通过一个非跨域的中间页面来传递数据。

   url的#后面的内容就叫hash。hash的改变，页面不会刷新，这就是用Hash做跨域通信的基本原理。

   #### 实现流程

   一开始 a.html 给 c.html 传一个 hash 值，然后 c.html 收到 hash 值后，再把 hash 值传递给 b.html，最后 b.html 将结果放到 a.html 的 hash 值中。 同样的，a.html 和 b.htm l 是同域的，都是 `http://localhost:8000`，而 c.html 是`http://localhost:8080`
   
   ```js
   // a.html
   <iframe src="http://localhost:8080/hash/c.html#name1"></iframe>
   <script>
     console.log(location.hash);
     window.onhashchange = function() {
       console.log(location.hash);
     };
   </script>
   
   // b.html
   <script>
     window.parent.parent.location.hash = location.hash;
   </script>
   
   // c.html
   <body></body>
   <script>
     console.log(location.hash);
     const iframe = document.createElement("iframe");
     iframe.src = "http://localhost:8000/hash/b.html#name2";
     document.body.appendChild(iframe);
   </script>
   ```


   [参考文章](https://juejin.cn/post/6844904126246027278
   )

6. ## **postMessage**

7. ## Ngnix反向代理（了解即可，运维做的事情）

# URL编码解码

```js
encodeURIComponent()   //URL编码方式
decodeURIComponent()   //解码
```

# 浏览器本地存储有哪些？

- **cookie**

- **webStorage**

  ​	localStorage

  ​	sessionStorage

- **indexDB**

# Localstorage、sessionStorage、cookie 的区别

- 共同点：都是保存在浏览器端、且同源的
- 区别：

1. cookie 数据始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器间来回传递，而 sessionStorage 和 localStorage 不会自动把数据发送给服务器，仅在本地保存。cookie 数据还有路径（path）的概念，可以限制 cookie 只属于某个路径下。
2. 存储大小限制也不同，cookie 数据不能超过 4K，同时因为每次 http 请求都会携带 cookie、所以 cookie 只适合保存很小的数据，如会话标识。sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。
3. 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage： 始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的 cookie 过期时间之前有效，即使窗口关闭或浏览器关闭
4. 作用域不同，sessionStorage 不在不同的浏览器窗口中共享，即使是同一个页面； localstorage 在所有同源窗口中都是共享的；cookie 也是在所有同源窗口中都是共享的
5. web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者
6. web Storage 的 api 接口使用更方便

# 进程线程

**一个进程**就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。

**线程**是依附于进程的，而进程中使用多线程并行处理能提升运算效率。

**进程和线程之间的关系**有以下4个特点

**1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃。**

**2. 线程之间共享进程中的数据。**

**3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。**

**4. 进程之间的内容相互隔离。**

# TCP和UDP

TCP（Transmission Control Protocol，传输控制协议）是一种**面向连接**的、**可靠的**、**基于字节流**的传输层通信协议。

UDP（User Datagram Protocol，用户数据报协议）**不能保证数据可靠性**，但是传输速度却非常快，所以UDP会应用在一些关注速度、但不那么严格要求数据完整性的领域，如**在线视频**、**互动游戏**等。

在使用UDP发送数据时，有各种因素会导致数据包出错，虽然UDP可以校验数据是否正确，但是对于错误的数据包，UDP并**不提供重发机制**，只是丢弃当前的包，而且UDP在发送之后也无法知道是否能达到目的地。

对于浏览器请求，或者邮件这类要求数据传输可靠性（reliability）的应用，如果使用UDP来传输会存在两个问题：

- 数据包在传输过程中容易丢失；
- 大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而UDP协议并不知道如何组装这些数据包，从而把这些数据包还原成完整的文件

所以相对于UDP，**TCP有下面两个特点**:

- 对于数据包丢失的情况，TCP**提供重传机制**；
- TCP引入了数据包**排序机制**，用来保证把乱序的数据包组合成一个完整的文件。

和UDP头一样，TCP头除了包含了目标端口和本机端口号外，还提供了用于排序的序列号，以便接收端通过序号来重排数据包。

一个TCP连接过程包括了**建立连接、传输数据和断开连接**三个阶段。

# 浏览器中的HTTP请求从发起到结束一共经历了哪些阶段？

浏览器中的HTTP请求从发起到结束一共经历了如下八个阶段：构建请求、查找缓存、准备IP和端口、等待TCP队列、建立TCP连接、发起HTTP请求、服务器处理请求、服务器返回请求和断开连接。

![img](https://static001.geekbang.org/resource/image/1b/6c/1b49976aca2c700883d48d927f48986c.png)![image-20210816194110663](../source/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3/image-20210816194110663.png)

# 从输入URL到页面展示，这中间发生了什么

- 用户输入url并回车
- 浏览器进程检查url，组装协议，构成完整的url
- 浏览器进程通过进程间通信（IPC）把url请求发送给网络进程
- 网络进程接收到url请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程
- 如果没有，网络进程向web服务器发起http请求（网络请求），请求流程如下:
  - 进行DNS解析，获取服务器ip地址，端口（端口是通过dns解析获取的吗？这里有个疑问）
  - 利用ip地址和服务器建立tcp连接
  - 构建请求头信息
  - 发送请求头信息
  - 服务器响应后，网络进程接收响应头和响应信息，并解析响应内容
- 网络进程解析响应流程；
  - 检查状态码，如果是301/302，则需要重定向，从Location自动中读取地址，重新进行第4步 （301/302跳转也会读取本地缓存吗？这里有个疑问），如果是200，则继续处理请求。
  - 200响应处理：检查响应类型Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行后续的渲染，如果是html则通知浏览器进程准备渲染进程准备进行渲染。
- 准备渲染进程
  - 浏览器进程检查当前url是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程
- 传输数据、更新状态
  - 渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道”
  - 渲染进程接收完数据后，向浏览器发送“确认提交”
  - 浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏url、前进后退的历史状态、更新web页面

# 一个完整的渲染流程

![image-20210817192121988](../source/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3/image-20210817192121988.png)

- 渲染进程将HTML内容转换为能够读懂的DOM树结构。
- 渲染引擎将CSS样式表转化为浏览器可以理解的styleSheets，计算出DOM节点的样式。
- 创建布局树，并计算元素的布局信息。
- 对布局树进行分层，并生成分层树。
- 为每个图层生成绘制列表，并将其提交到合成线程。
- 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
- 合成线程发送绘制图块命令（DrawQuad）给浏览器进程。
- 浏览器进程根据绘制命令（DrawQuad）生成页面，并显示到显示器上

### 1. 更新了元素的几何属性（重排）

![img](../source/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3/b3ed565230fe4f5c1886304a8ff754e5.png)

从上图可以看出，如果你通过JavaScript或者CSS修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。无疑，重排需要更新完整的渲染流水线，所以开销也是最大的

### 2. 更新元素的绘制属性（重绘）

接下来，我们再来看看重绘，比如通过JavaScript更改某些元素的背景颜色，渲染流水线会怎样调整呢？你可以参考下图。

![img](../source/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3/3c1b7310648cccbf6aa4a42ad0202b03.png)

从图中可以看出，如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。**相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些**。

### 3. 直接合成阶段

那如果你更改一个既不要布局也不要绘制的属性，会发生什么变化呢？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成。具体流程参考下图。

![img](../source/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3/024bf6c83b8146d267f476555d953a2c.png)

在上图中，我们使用了CSS的transform来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。

# 垃圾回收

##### [标记清除（mark and sweep）](https://ramona-chen.top/web-book/#/JavaScript/jsBase?id=标记清除（mark-and-sweep）)

- 这是 JavaScript 最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”
- **垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包）**，在这些完成之后仍存在标记的就是要删除的变量了

##### [引用计数(reference counting)](https://ramona-chen.top/web-book/#/JavaScript/jsBase?id=引用计数reference-counting)

- 在低版本 IE 中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。**引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加 1，如果该变量的值变成了另外一个，则这个值得引用次数减 1**，当这个值的引用次数变为 0 的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的空间。

# 内存泄漏及优化

## 什么是内存泄露

存泄露是指程序中已分配的堆内存由于某种原因未释放或者无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统奔溃等后果。

## 常见的内存泄露的场景

- 缓存
- 作用域未释放（闭包）
- 没有必要的全局变量
- 无效的 DOM 引用
- 定时器未清除
- 事件监听为空白

## 内存泄露优化

1. 在业务不需要的用到的内部函数，可以重构到函数外，实现解除闭包。
2. 避免创建过多的生命周期较长的对象，或者将对象分解成多个子对象。
3. 避免过多使用闭包。
4. 注意清除定时器和事件监听器。
5. nodejs 中使用 stream 或 buffer 来操作大文件，不会受 nodejs 内存限制。

# 浏览器缓存

[参考文章](https://juejin.cn/post/6844903763665240072#heading-0)