# 同源和跨域

**同源策略**是浏览器的一种安全策略，所谓同源是指，域名，协议，端口（http协议的默认端口是80）完全相同。

同源策略主要**限制**了三个方面：

1. **DOM层面**：不同源站点之间不能相互访问和操作DOM
2. **数据层面**：不能获取不同源站点的Cookie、LocalStorage、indexDB等数据
3. **网络层面**：不能通过XMLHttpRequest向不同源站点发送请求（不能发送Ajax请求）

当然**同源策略限制也不是绝对隔离不同源的站点**，比如link、img、script标签都没有跨域限制，这让我们开发更灵活了，但是也同样带来了一些安全问题，也就是**浏览器网络安全**问题，最典型的就是XSS攻击和CSRF攻击。

# XSS攻击（Cross Site Scripting—跨域脚本攻击）

XSS攻击是一种`代码注入攻击`，通过恶意注入脚本在浏览器运行，然后盗取用户信息

**造成XSS攻击其实本质上还是因为网站没有过滤恶意代码，与正常代码混在一起之后，浏览器没有办法分辨哪些是可信的，然后导致恶意代码也被执行**。然后可能导致以下情况：

- 页面数据或用户信息被窃取，如DOM、Cookie、LocalStorage

- 修改DOM，比如伪造登录窗口或在页面生成浮窗广告

- 监听用户行为，比如在登录或银行等站点用 addEventListener 监听键盘事件，窃取账号密码等信息

- 流量被劫持向其他网站

  XSS攻击有三种类型：**存储型**、**反射型**、**DOM型**

  ## 存储型 XSS

  存储型 XSS 的攻击步骤：

  攻击者将恶意代码提交到目标网站的数据库中。 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。

  ## 反射型 XSS

  反射型 XSS 的攻击步骤：

  - 攻击者构造出特殊的 URL，其中包含恶意代码。
  - 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。
  - 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
  - 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

  反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。

  反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。

  由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。

  POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。

  ## DOM 型 XSS

  DOM 型 XSS 的攻击步骤：

  - 攻击者构造出特殊的 URL，其中包含恶意代码。
  - 用户打开带有恶意代码的 URL。
  - 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。
  - 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

  DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。

  **防护策略：**

  - 就是对输入框的内容进行`过滤`或使用转义符进行`转码`
  - 使用CSP，就是`白名单`，告诉浏览器哪些外部资源可以加载执行，让即使插入进来恶意代码的也不会执行，或者可以向哪些第三方站点提交数据。开启白名单的方式有两种：
    - 使用 meta 标签 `<meta http-equiv="Content-Security-Policy">`
    - 设置http头部的 `Content-Security-Policy`
  - 对一些敏感信息进行保护，在`Cookie`信息中添加`httpOnly`，告诉浏览器在保存Cookie，且不要对客户端脚本开放访问权限，然后就不能通过document.cookie获取cookie了

  ```
  Set-Cookie: widget_session=123456; httpOnly
  ```

  - 使用`验证码`，避免脚本伪装成用户执行一些操作

  **前端如何防护XSS攻击：**

  1. 前端在显示服务端数据时候，不仅是标签内容需要过滤、转义，就连属性值也都可能需要。

  2. 使用HTTPS！就跟我前面《[HTTP与HTTPS握手的那些事](http://www.cnblogs.com/lovesong/p/5186200.html)》这篇文章说的，HTTPS会在请求数据之前进行一次握手，使得客户端与服务端都有一个私钥，服务端用这个私钥加密，客户端用这个私钥解密，这样即使数据被人截取了，也是加密后的数据。

# CSRF攻击（Cross Site Request Forgery—跨站请求伪造）

**主要就是利用用户的登录状态发起跨站请求**，比如邮箱里的乱七八糟的链接，打开链接的时候邮箱肯定是处于登录状态，然后黑客就可以用这个登录状态，伪造带有正确 Cookie 的 http 请求，直接绕过后台的登录验证，然后冒充用户执行一些操作。

发起CSRF攻击有**三个必要条件**：

1. 目标网站一定要有CSRF漏洞

2. 用户登录过目标网站，并且浏览器保存了登录状态

3. 需要用户主动打开第三方站点

   CSRF攻击也有三种类型：**GET类型**、**POST类型**、**链接型**

   - `自动发GET类型`：比如`img`或`iframe`标签等，当用户打开这个网站时会自动发起带Cookie的资源请求

   ```html
   <img src="http://恶意网址" >
   复制代码
   ```

   - `自动发POST类型`：比如整一个隐藏的`表单`，在用户进入页面的时候自动提交表单

   ```html
   <form id="hack" action="https://恶意网址" method="post">
       ...
   </form>
   <script>document.getElementById('hack').submit()</script>
   复制代码
   ```

   - `诱导链接型`：就是诱导用户主动点击链接，比如`a标签`

   ```html
   <a href="https://恶意网址">点击领取大礼包</a>
   <a href="https://恶意网址">点击下载美女视频</a>
   ```

**防护策略**:

在Cookie信息中添加`SameSite`属性，这个属性有三个值：

- **strict**：**严格模式**，完全禁止使用Cookie
- **lax**：**宽松模式**，允许部分情况使用Cookie，`跨域的都行`，a标签跳转，link标签，GET提交表单
- **none**：任何情况下都会发送Cookie，但必须同时设置Secure属性，意思是需要安全上下文，Cookie 只能通过https发送，否则无效

Chrome 80之前默认值是none，之后是lax

```javascript
Set-Cookie: widget_session=123456; SameSite=None; Secure
```

`验证请求来源`：服务器根据http请求头中的`Origin`或`Referer`属性判断是否为允许访问的站点，从而对请求进行过滤。优先判断Origin，如果两个都不存在的话就直接阻止。

- Referer：记录了请求是从哪个链接跳过来的并且包含了路径信息，也就是来源地址。不过这家伙不太可靠，所以后来又新增了Origin属性

  ```
  Referer: https://juejin.cn/editor/drafts/xxxx
  ```

- origin：记录了域名信息，没有具体的URL路径

  ```
  Origin: https://juejin.cn
  ```

`Token验证`：服务器向用户返回一个随机数Token，再次请求时在请求头中以参数的形式添加入这个Token，然后服务器验证这个Token，如果没有或者内容不正确，就拒绝请求。缺点是

- 每个请求都得添加比较繁琐
- 单方面验证Cookie可能会被冒用，
- 如果网站不止一台服务器，通过负载均衡转到了其他服务器的话，其他所有服务器中的Session中都得保留Token，不然就验证不了了

`双重验证Cookie`：利用攻击者只能利用Cookie，不能获取Cookie的特点，用户访问页面时，服务器向请求域名添加一个Cookie随机字符串，然后，用户再次请求时从Cookie中取出这个字符串，添加到URL参数中，然后服务器通过对Cookie中的数据和参数中的数据对比验证，不一样就拒绝请求。

**缺点**是如果网站存在XSS漏洞，这法子就会失效，而且不能做到子域名的隔离

# 跨域通信的几种方式

## JSONP

**JSONP的原理**：**通过`<script>`标签的异步加载来实现的**。比如说，实际开发中，我们发现，head标签里，可以通过`<script>`标签的src，里面放url，加载很多在线的插件。这就是用到了JSONP。

**核心思想：**网页通过添加一个`<script>元素`，向服务器请求 JSON 数据，服务器收到请求后，将数据放在一个指定名字的回调函数的参数位置传回来。

不过`只支持GET请求`且`不安全`，**可能遇到XSS攻击，不过它的好处是可以向老浏览器或不支持CORS的网站请求数据**

## WebSocket

[WebSocket](http://websocket.org/) 是一种网络通信协议，我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？因为 HTTP 协议有一个缺陷：通信只能由客户端发起。**HTTP 协议做不到服务器主动向客户端推送信息。**

这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用["轮询"](https://www.pubnub.com/blog/2014-12-01-http-long-polling/)：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。

WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。

它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于[服务器推送技术](https://en.wikipedia.org/wiki/Push_technology)的一种。

其他特点包括：

（1）建立在 TCP 协议之上，服务器端的实现比较容易。

（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。

（3）数据格式比较轻量，性能开销小，通信高效。

（4）可以发送文本，也可以发送二进制数据。

（5）**没有同源限制，客户端可以与任意服务器通信**。

（6）协议标识符是`ws`（如果加密，则为`wss`），服务器网址就是 URL。

WebSocket的用法如下：

```js
var ws = new WebSocket('wss://echo.websocket.org'); //创建WebSocket的对象。参数可以是 ws 或 wss，后者表示加密。

//把请求发出去
ws.onopen = function (evt) {
console.log('Connection open ...');
ws.send('Hello WebSockets!');
};


//对方发消息过来时，我接收
ws.onmessage = function (evt) {
console.log('Received Message: ', evt.data);
ws.close();
};

//关闭连接
ws.onclose = function (evt) {
console.log('Connection closed.');
};
```

```js
// socket.html
<script>
    let socket = new WebSocket('ws://localhost:3000');//创建WebSocket的对象。参数可以是 ws 或 wss，后者表示加密。
    socket.onopen = function () {
      socket.send('我爱你');//向服务器发送数据
    }
    socket.onmessage = function (e) {
      console.log(e.data);//接收服务器返回的数据
    }
</script>

// server.js
let express = require('express');
let app = express();
let WebSocket = require('ws');//记得安装ws
let wss = new WebSocket.Server({port:3000});
wss.on('connection',function(ws) {
  ws.on('message', function (data) {
    console.log(data);
    ws.send('我不爱你')
  });
})
```

## 代理Proxy（只在生产环境中使用）

​		通过中间件来实现，浏览器有跨域限制，但是服务器没有跨域限制，所以中间件其实就是服务器（服务器对数据进行了转发），此方法在vue中经常用到（在vue的配置文件里设置代理）。

​		例如当baidu.com域下的页面需要请求google.com下的资源文件getUsers.php时，直接发送一个指向  google.com/getUsers.php的Ajax请求肯定是会被浏览器阻止。这时，我们在baidu.com下配一个代理，然后把Ajax请求绑定到这个代理路径下，例如baidu.com/proxy/,  然后这个代理发送HTTP请求访问google.com下的getUsers.php，跨域的HTTP请求是在服务器端进行的（服务器端没有同源策略限制），客户端并没有产生跨域的Ajax请求。这个跨域方式不需要和目标资源签订协议，带有侵略性。

代理服务器需要做以下事情：

- 接受客户端请求 。
- 将请求转发给服务器。
- 拿到服务器响应数据。
- 将 响应转发给客户端。

![image-20210814133216235](../source/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3/image-20210814133216235.png)

![image-20210814134517030](../source/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3/image-20210814134517030.png)

## CORS

只需要在服务器端设置Access-Control-Allow-Origin即可（服务器允许跨域，若后面值为*号，则表示服务器允许所有的源都可以请求），前端无需配置，**若要带cookie请求**，则前端后端都需要配置。

#### 简单请求

需要同时满足两个条件，就属于简单请求：

- 请求方法是：`HEAD`、`GET`、`POST`，三者之一
- 请求头信息不超过以下几个字段：
  - Accept
  - Accept-Language
  - Content-Language
  - Last-Event-Id
  - Content-Type：值为三者之一application/x-www/form/urlencoded、multipart/form-data、text/plain

需要这些条件是为了兼容表单，因为历史上表单一直可以跨域

浏览器直接发出CORS请求，具体来说就是在头信息中增加Origin字段，表示请求来源来自哪个域(协议+域名+端口)，服务器根据这个值决定是否同意请求。如果同意，返回的响应会多出以下响应头信息

```js
Access-Control-Allow-Origin: http://juejin.com // 和 Orign 一致  这个字段是必须的
Access-Control-Allow-Credentials: true // 表示是否允许发送 Cookie  这个字段是可选的
Access-Control-Expose-Headers: FooBar // 指定返回其他字段的值   这个字段是可选的
Content-Type: text/html; charset=utf-8 // 表示文档类型
复制代码
```

在简单请求中服务器至少需要设置：`Access-Control-Allow-Origin` 字段

#### 非简单请求

比如 PUT 或 DELETE 请求，或 Content-Type 为 application/json ，就是非简单请求。

非简单 CORS 请求，**正式请求前会发一次 OPTIONS 类型的查询请求**，称为`预检请求`，询问服务器是否支持网页所在域名的请求，以及可以使用哪些头信息字段。只有收到肯定的答复，才会发起正式XMLHttpRequest请求，否则报错

预检请求的方法是OPTIONS，它的头信息中有几个字段

- Origin: 表示请求来自哪个域，这个字段是必须的
- Access-Control-Request-Method：列出CORS请求会用到哪些HTTP方法，这个字段是必须的
- Access-Control-Request-Headers： 指定CORS请求会额外发送的头信息字段，用逗号隔开

OPTIONS请求次数过多也会损耗性能，所以要尽量减少OPTIONS请求，可以让服务器在请求返回头部添加

```js
Access-Control-Max-Age: Number // 数字 单位是秒
复制代码
```

表示预检请求的返回结果可以被缓存多久，在这个时间范围内再请求就不需要预检了。不过这个缓存只对完全一样的URL才会生效

## Hash

原理就是通过 url 带 hash ，通过一个非跨域的中间页面来传递数据。

url的#后面的内容就叫hash。hash的改变，页面不会刷新，这就是用Hash做跨域通信的基本原理。

#### 实现流程

一开始 a.html 给 c.html 传一个 hash 值，然后 c.html 收到 hash 值后，再把 hash 值传递给 b.html，最后 b.html 将结果放到 a.html 的 hash 值中。 同样的，a.html 和 b.htm l 是同域的，都是 `http://localhost:8000`，而 c.html 是`http://localhost:8080`

```js
// a.html
<iframe src="http://localhost:8080/hash/c.html#name1"></iframe>
<script>
  console.log(location.hash);
  window.onhashchange = function() {
    console.log(location.hash);
  };
</script>

// b.html
<script>
  window.parent.parent.location.hash = location.hash;
</script>

// c.html
<body></body>
<script>
  console.log(location.hash);
  const iframe = document.createElement("iframe");
  iframe.src = "http://localhost:8000/hash/b.html#name2";
  document.body.appendChild(iframe);
</script>
```


   [参考文章](https://juejin.cn/post/6844904126246027278
   )

## postMessage

## Ngnix反向代理（了解即可，运维做的事情）

# URL编码解码

```js
encodeURIComponent()   //URL编码方式
decodeURIComponent()   //解码
```

# 浏览器本地存储有哪些？

- **cookie**

- **webStorage**

  ​	localStorage

  ​	sessionStorage

- **indexDB**

# Localstorage、sessionStorage、cookie 的区别

- 共同点：都是保存在浏览器端、且同源的
- 区别：

1. cookie 数据始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器间来回传递，而 sessionStorage 和 localStorage 不会自动把数据发送给服务器，仅在本地保存。cookie 数据还有路径（path）的概念，可以限制 cookie 只属于某个路径下。
2. 存储大小限制也不同，cookie 数据不能超过 4K，同时因为每次 http 请求都会携带 cookie、所以 cookie 只适合保存很小的数据，如会话标识。sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。
3. 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage： 始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的 cookie 过期时间之前有效，即使窗口关闭或浏览器关闭
4. 作用域不同，sessionStorage 不在不同的浏览器窗口中共享，即使是同一个页面； localstorage 在所有同源窗口中都是共享的；cookie 也是在所有同源窗口中都是共享的
5. web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者
6. web Storage 的 api 接口使用更方便

# Cookie

**Cookie表示在HTTP服务器和客户之间传递的状态信息。**（由于HTTP是无状态的，但是有时服务器需要记住用户的身份，也可能想限制某些用户的访问，要做到这点，可以在HTTP种使用Cookie）。

## Cookie是如何工作的

假设你总是从家中PC使用IE上网，你首次与www.taobao.com联系。我们假定过去她已经访问过京东站点。当请求报文到达淘宝的服务器时，该Web站点将产生一个唯一识别码，并以此作为索引在它的后端数据库中产生一个表项。接下来淘宝的Web服务器用一个包含Set-cookie：首部的HTTP相应报文对你的浏览器进行相应，其中Set-cookie:首部含有该识别码。
例如，该首部行可能是 **Set-cookie：1678**。
		当你的浏览器收到了该HTTP响应报文时，它会看到该Set-cookie：首部。该浏览器在它管理的特定cookie文件中添加一行，该行包含服务器的主机名和在Set-cookie: 首部中的识别码。值得注意的时该cookie文件已经有了用于京东的表项，因此你过去访问过该站点，当你继续浏览淘宝网站时，每请求一个Web页面，其浏览器就会从该cookie文件中获取她对这个网站的识别码，并放到http请求报文中包括识别码的cookie首部行中。特别是，发往该淘宝服务器的每个HTTP请求报文都包括以下首部行：**Cookie：1678**。
		在这种方式下，淘宝服务器可以跟踪你在淘宝站点的活动。尽管淘宝的Web站点不必知道你的名字，但她确切的知道用户1678按照什么顺序，在什么时间，访问了哪些页面，淘宝使用cookie来提供它的购物车服务，即淘宝能购维护你希望购买的物品列表，这样你在结束会话时可以一起为他们付费。
		如果你再次访问淘宝站点，比如一星期后，你的浏览器会在请求报文中继续放入首部行cookie：1678。。淘宝将根据你过去在淘宝访问的网页向你推送产品。
		cookie可以用于标识一个用户，用户首次访问一个站点时可能需要提供一个用户标识。在后继会话中，浏览器向服务器传递一个cookie首部，从而向该服务器标识了用户。因此cookie可以在无状态的HTTP上建立一个用户会话层。

[原文链接](https://blog.csdn.net/nhgfd/article/details/78213008)

# 进程线程

**一个进程**就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。

**线程**是依附于进程的，而进程中使用多线程并行处理能提升运算效率。

**进程和线程之间的关系**有以下4个特点

**1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃。**

**2. 线程之间共享进程中的数据。**

**3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。**

**4. 进程之间的内容相互隔离。**

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

最新的Chrome浏览器包括：1个浏览器（Browser）主进程、1个 GPU 进程、1个网络（NetWork）进程、多个渲染进程和多个插件进程。

- **浏览器进程**。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
- **渲染进程**。核心任务是将 HTML、CSS 和 JavaScript  转换为用户可以与之交互的网页，排版引擎Blink和JavaScript引擎V8都是运行在该进程中，默认情况下，Chrome会为每个Tab标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
- **GPU进程**。其实，Chrome刚开始发布的时候是没有GPU进程的。而GPU的使用初衷是为了实现3D CSS的效果，只是随后网页、Chrome的UI界面都选择采用GPU来绘制，这使得GPU成为浏览器普遍的需求。最后，Chrome在其多进程架构上也引入了GPU进程。
- **网络进程**。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
- **插件进程**。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响

所以可以回答仅仅打开了1个页面，为什么有4个进程的问题了——因为打开1个页面至少需要1个网络进程、1个浏览器进程、1个GPU进程以及1个渲染进程，共4个；如果打开的页面有运行插件的话，还需要再加上1个插件进程。

[参考文章](https://blog.poetries.top/browser-working-principle/guide/part1/lesson01.html#%E7%9B%AE%E5%89%8D%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9E%B6%E6%9E%84)

# TCP和UDP

TCP（Transmission Control Protocol，传输控制协议）是一种**面向连接**的、**可靠的**、**基于字节流**的传输层通信协议。

UDP（User Datagram Protocol，用户数据报协议）**不能保证数据可靠性**，但是传输速度却非常快，所以UDP会应用在一些关注速度、但不那么严格要求数据完整性的领域，如**在线视频**、**互动游戏**等。

在使用UDP发送数据时，有各种因素会导致数据包出错，虽然UDP可以校验数据是否正确，但是对于错误的数据包，UDP并**不提供重发机制**，只是丢弃当前的包，而且UDP在发送之后也无法知道是否能达到目的地。

对于浏览器请求，或者邮件这类要求数据传输可靠性（reliability）的应用，如果使用UDP来传输会存在两个问题：

- 数据包在传输过程中容易丢失；
- 大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而UDP协议并不知道如何组装这些数据包，从而把这些数据包还原成完整的文件

所以相对于UDP，**TCP有下面两个特点**:

- 对于数据包丢失的情况，TCP**提供重传机制**；
- TCP引入了数据包**排序机制**，用来保证把乱序的数据包组合成一个完整的文件。

和UDP头一样，TCP头除了包含了目标端口和本机端口号外，还提供了用于排序的序列号，以便接收端通过序号来重排数据包。

一个TCP连接过程包括了**建立连接、传输数据和断开连接**三个阶段。

# 浏览器中的HTTP请求从发起到结束一共经历了哪些阶段？

浏览器中的HTTP请求从发起到结束一共经历了如下八个阶段：构建请求、查找缓存、准备IP和端口、等待TCP队列、建立TCP连接、发起HTTP请求、服务器处理请求、服务器返回请求和断开连接。

![img](https://static001.geekbang.org/resource/image/1b/6c/1b49976aca2c700883d48d927f48986c.png)

# 从输入URL到页面展示，这中间发生了什么

- 用户输入url并回车
- 浏览器进程检查url，组装协议，构成完整的url
- 浏览器进程通过进程间通信（IPC）把url请求发送给网络进程
- 网络进程接收到url请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程
- 如果没有，网络进程向web服务器发起http请求（网络请求），请求流程如下:
  - 进行DNS解析，获取服务器ip地址，端口（端口是通过dns解析获取的吗？这里有个疑问）
  - 利用ip地址和服务器建立tcp连接
  - 构建请求头信息
  - 发送请求头信息
  - 服务器响应后，网络进程接收响应头和响应信息，并解析响应内容
- 网络进程解析响应流程；
  - 检查状态码，如果是301/302，则需要重定向，从Location自动中读取地址，重新进行第4步 （301/302跳转也会读取本地缓存吗？这里有个疑问），如果是200，则继续处理请求。
  - 200响应处理：检查响应类型Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行后续的渲染，如果是html则通知浏览器进程准备渲染进程准备进行渲染。
- 准备渲染进程
  - 浏览器进程检查当前url是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程
- 传输数据、更新状态
  - 渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道”
  - 渲染进程接收完数据后，向浏览器发送“确认提交”
  - 浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏url、前进后退的历史状态、更新web页面

# 一个完整的渲染流程

![image-20210817192121988](../source/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3/image-20210817192121988.png)

- 渲染进程将HTML内容转换为能够读懂的DOM树结构。
- 渲染引擎将CSS样式表转化为浏览器可以理解的styleSheets，计算出DOM节点的样式。
- 创建布局树，并计算元素的布局信息。
- 对布局树进行分层，并生成分层树。
- 为每个图层生成绘制列表，并将其提交到合成线程。
- 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
- 合成线程发送绘制图块命令（DrawQuad）给浏览器进程。
- 浏览器进程根据绘制命令（DrawQuad）生成页面，并显示到显示器上

## 1. 更新了元素的几何属性（重排）

![img](../source/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3/b3ed565230fe4f5c1886304a8ff754e5.png)

从上图可以看出，如果你通过JavaScript或者CSS修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。无疑，重排需要更新完整的渲染流水线，所以开销也是最大的

## 2. 更新元素的绘制属性（重绘）

接下来，我们再来看看重绘，比如通过JavaScript更改某些元素的背景颜色，渲染流水线会怎样调整呢？你可以参考下图。

![img](../source/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3/3c1b7310648cccbf6aa4a42ad0202b03.png)

从图中可以看出，如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。**相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些**。

## 3. 直接合成阶段

那如果你更改一个既不要布局也不要绘制的属性，会发生什么变化呢？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成。具体流程参考下图。

![img](../source/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3/024bf6c83b8146d267f476555d953a2c.png)

在上图中，我们使用了CSS的transform来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。

# 垃圾回收

##### [标记清除（mark and sweep）](https://ramona-chen.top/web-book/#/JavaScript/jsBase?id=标记清除（mark-and-sweep）)

- 这是 JavaScript 最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”
- **垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包）**，在这些完成之后仍存在标记的就是要删除的变量了

##### [引用计数(reference counting)](https://ramona-chen.top/web-book/#/JavaScript/jsBase?id=引用计数reference-counting)

- 在低版本 IE 中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。**引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加 1，如果该变量的值变成了另外一个，则这个值得引用次数减 1**，当这个值的引用次数变为 0 的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的空间。

# 内存泄漏及优化

## 什么是内存泄露

存泄露是指程序中已分配的堆内存由于某种原因未释放或者无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统奔溃等后果。

## 常见的内存泄露的场景

- 缓存
- 作用域未释放（闭包）
- 没有必要的全局变量
- 无效的 DOM 引用
- 定时器未清除
- 事件监听为空白

## 内存泄露优化

1. 在业务不需要的用到的内部函数，可以重构到函数外，实现解除闭包。
2. 避免创建过多的生命周期较长的对象，或者将对象分解成多个子对象。
3. 避免过多使用闭包。
4. 注意清除定时器和事件监听器。
5. nodejs 中使用 stream 或 buffer 来操作大文件，不会受 nodejs 内存限制。

# 浏览器缓存

[参考文章](https://juejin.cn/post/6844903763665240072#heading-0)

# 几种常见的Content-type类型

1. application/x-www-form-urlencoded    form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）

2. multipart/form-data    需要在表单中进行文件上传时，就需要使用该格式

3. application/json      JSON数据格式

4. text/xml      XML格式

5. binary (application/octet-stream)     二进制流数据（如常见的文件下载）

   ...

[参考文章](https://www.runoob.com/http/http-content-type.html)

# GET和POST请求的区别

- GET参数通过url传递，所以是有长度限制的，POST放在body中，所以没有长度限制。（http协议规定，url在请求头中，所以大小限制很小）
- GET在浏览器回退时是无害的，而POST会再次提交请求。
- GET请求会被浏览器主动Cache,而POST不会，除非手动设置。
- GET比POST更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息。
- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
- GET请求只能进行url（x-www-form-urlencoded）编码，而POST支持多种编码方式。
- GET产生一个TCP数据包，POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http的header和data一并发送出去，服务器响应200（返回数据）。而对于POST，浏览器先发送header，服务器响应100，浏览器在发送data,服务器响应200 ok(返回数据)

# HTTP状态码

- 1XX（信息状态码）——接收的请求正在处理

  ​	100 continue 继续  一般在发送post请求时，已发送了http header之后服务器端将返回此信息，表示确认，之后发送具体参数信息。

- 2XX（成功状态码）——请求正常处理完毕

  ​	200 ok 正常返回信息

  ​	201 created 请求成功并且服务器创建了新资源

  ​	202  accepted 服务器已经接收请求，但尚未处理

- 3XX（重定向状态码）——需要进行附加操作以完成请求

  ​	301 move per 请求的网页已经永久重定向

  ​	302 found 临时重定向

  ​	303 see other 临时重定向，且总是使用get请求新的url

  ​	304 not modified 自从上次请求后，请求的网页未修改过

- 4XX（客户端错误状态码）——服务器无法处理请求

  ​	400 bad request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求

  ​	401 unauthorized 请求未授权

  ​	403 forbidden 禁止访问

  ​	404 not found 找不到如何与url匹配的资源

- 5XX（服务器错误状态码）——服务器处理请求出错

  ​	500 internal server error 最常见的服务器端的错误

  ​	503 service unacailable 服务器端暂时无法处理请求（可能是过载或维护）

# 登录状态是如何保持的？

- 通过上面的介绍，你已经了解了缓存是如何工作的。下面我们再一起看下登录状态是如何保持的。
- 用户打开登录页面，在登录框里填入用户名和密码，点击确定按钮。点击按钮会触发页面脚本生成用户登录信息，然后调用POST方法提交用户登录信息给服务器。
- 服务器接收到浏览器提交的信息之后，查询后台，验证用户登录信息是否正确，如果正确的话，会生成一段表示用户身份的字符串，并把该字符串写到响应头的`Set-Cookie`字段里，如下所示，然后把响应头发送给浏览器

```text
Set-Cookie: UID=3431uad;
```

- 浏览器在接收到服务器的响应头后，开始解析响应头，如果遇到响应头里含有Set-Cookie字段的情况，浏览器就会把这个字段信息保存到本地。比如把UID=3431uad保持到本地。
- 当用户再次访问时，浏览器会发起HTTP请求，但在发起请求之前，浏览器会读取之前保存的Cookie数据，并把数据写进请求头里的Cookie字段里（如下所示），然后浏览器再将请求头发送给服务器。

```text
Cookie: UID=3431uad;
```

- 服务器在收到HTTP请求头数据之后，就会查找请求头里面的“Cookie”字段信息，当查找到包含UID=3431uad的信息时，服务器查询后台，并判断该用户是已登录状态，然后生成含有该用户信息的页面数据，并把生成的数据发送给浏览器。
- 浏览器在接收到该含有当前用户的页面数据后，就可以正确展示用户登录的状态信息了

好了，通过这个流程你可以知道浏览器页面状态是通过使用Cookie来实现的。Cookie流程可以参考下图：

![img](../source/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3/d9d6cefe8d3d6d84a37a626687c6ecb3.png)

简单地说，如果服务器端发送的响应头内有 Set-Cookie 的字段，那么浏览器就会将该字段的内容保持到本地。当下次客户端再往该服务器发送请求时，客户端会自动在请求头中加入  Cookie  值后再发送出去。服务器端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到该用户的状态信息。

[参考文档](https://blog.poetries.top/browser-working-principle/guide/part1/lesson03.html#_1-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BE%88%E5%A4%9A%E7%AB%99%E7%82%B9%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%89%93%E5%BC%80%E9%80%9F%E5%BA%A6%E4%BC%9A%E5%BE%88%E5%BF%AB%EF%BC%9F)